#Lab7 Report

##练习1
---
1.理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题（不需要编码），给出内核级信号量的设计描述，并说其大致执行流流程。
>	内核级信号量由semaphore_t数据结构实现，其中有int value记录资源数，wait_queue_t wait_queue记录等待队列。其还有一系列操作（函数），包括sema_init，up，down，try_down。其中sema_init为初始化函数，会设定资源数value并初始化等待队列为空；up函数为V操作，会先关中断查询等待队列是否为空，如为空则资源书加1，如不空则唤醒一个等待进程，最后开中断；down函数为P操作，会先关中断，然后看资源value是否大于0，如大于0则减1，否则将该进程加入等待队列并进行调度，最后关中断；try_down会先关中断，然后看资源value是否大于0，如大于0则减1，最后关中断。



2.给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。

>	用户态与内核态最大的不同是用户态进程无法使用开关中断的指令，所以课以将内核级信号量包装成系统调用的形式供用户态进程调用，以此完成用户态进程/线程的信号量机制。

##练习2
---
1.完成内核级条件变量和基于内核级条件变量的哲学家就餐问题（需要编码）设计思路，给出内核级条件变量的设计描述，并说其大致执行流流程。

>	按照注释以及视频的提示，实现了monitor.c中的cond_signal和cond_wait函数，最后在check_sync.c中实现了哲学家就餐问题的相应函数。
>	
>	代码方面按照注释和视频写出，在phi_take_forks_condvar函数中，有一个判断语句我按照视频写出为if(state_condvar[i] != EATING)与标准答案while(state_condvar[i] != EATING)不同。
>	
>	内核级条件变量的数据结构为condvar，其中semaphore_t sem用来实现等待队列，int count用来计数等待队列中的进程，monitor_t * owner用来绑定管程。还有cond_signal函数，首先检查是否有进程执行了cond_wait而等待，如有，则唤醒，如无则返回；cond_wait函数，首先检查是否有进程执行了cond_signal而等待，如有，则唤醒，如无则交出管程的mutex锁。

2.给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。

>	用户态进程的条件变量机制可以使用信号量机制实现，无论是基于系统调用的内核级信号量还是用户级信号量均可。