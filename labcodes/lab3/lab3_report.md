#Lab3 Report

##练习1
---
1.给未被映射的地址映射上物理页设计思路

>	按照注释提示，先用get_pte函数得到一个二级页表项，如果其为0则表示该页既不在物理内存中也不在虚存中，此时需要分配新物理页，并将虚拟地址与其绑定。需要注意的是要对函数的返回值进行检查，如果其为NULL要进行报错并跳转到failed标签。
>	
>	代码方面按照注释写出，除代码风格外，功能与标准答案基本相同。	
2.请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处

>	这两项都由两部分构成，一是标志位，二是表项。标志位的功能是记录控制信息，如是否在内存中，是否有写权限等等，而表项则记录有内容，页目录项记录的是二级页表所在的物理地址，二级页表项记录的是页的物理地址。潜在用处是可以方便的进行内存以及权限管理。

3.如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

>	触发异常，进入异常处理程序，如果是访问权限不足，则报错，如果是缺页异常，则需要将页表从硬盘中调入内存中（如果此时内存已满，还需将根据页替换策略将页换出到硬盘），最后跳会异常指令处并恢复现场。



##练习2
---
1.补充完成基于FIFO的页面替换算法设计思路

>	do_pgfault函数如练习1般，按照注释提示写出。对于swap_fifo.c中的代码，有许多与标准答案不同之处。在_fifo_map_swappable函数中，对于swap_in参数，我并不知道其是什么作用（注释也没有给出），但在调用时我认为是为1则执行，所以在_fifo_map_swappable函数中我也进行了判断，但是结果运行出错，当我删去时则通过，不知道是什么原因。此外，在_fifo_swap_out_victim函数中，我并没有用assert语句来检查错误情况，因为我认为经过处理后，依然能正常工作，代码如下。

```
static int
_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)
{
     list_entry_t *head=(list_entry_t*) mm->sm_priv;
         assert(head != NULL);
     assert(in_tick==0);
     struct Page *p = le2page(head->prev, pra_page_link);
     if(head != head->prev){
        list_del(head->prev);
     }
     *ptr_page = p;
     return 0;
}
```


2.如果要在ucore上实现"extended clock页替换算法"请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题：

>	可以。

2.1需要被换出的页的特征是什么？

>	最近未被访问和修改的页。

2.2在ucore中如何判断具有这样特征的页？

>	查找使用位和修改位都为0的页。

2.3何时进行换入和换出操作？

>	缺页时寻找最近未被访问和修改的页进行换入换出操作。