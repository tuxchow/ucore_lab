#Lab5 Report

##练习1
---
1.加载应用程序并执行设计思路

>	按照注释提示，将tf_cs设置为代码段，ds,es,ss设置为数据段，esp设置为用户栈顶，eip设置为程序入口，eflags设置为FL_IF能够产生中断。
>	
>	代码方面按照注释写出，除代码风格外，功能与标准答案基本相同。



2.请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

>	首先加载该进程的堆栈，即esp0，然后加载该进程的页表cr3，最后通过switchto函数将当前进程的eip压栈，并将eip设置为新进程eip（load_icode中设置的程序入口），之后ret到新进程用户态执行。


##练习2
---
1.父进程复制自己的内存空间给子进程设计思路

>	按照注释提示，将父进程page和子进程npage转化为虚地址，然后将page内容复制给npage，最后将npage插入到子进程页表中。
>	
>	代码方面按照注释写出，除代码风格外，功能与标准答案基本相同。



2.请在实验报告中简要说明如何设计实现”Copy on Write 机制“，给出概要设计，鼓励给出详细设计。

>	当复制进程时可以先将父进程的所有信息复制给子进程，并将其页表项都设置为只读，当任意进程对页面发生写操作时，进入page fault处理copy on write机制，此时再为子进程分配新的页面即调用copy_range，最后将其页表项都改为可读可写。

##练习3
---

1.请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？

>	fork:复制子进程，并将子进程状态设置为RUNNABLE
>	exec:将二进制程序加载进进程，对状态无影响
>	wait:检测进程的子进程，若为ZOMBIE状态则清理子进程，否则将当前进程置为SLEEPING并进行调度
>	exit:释放该进程资源，并将其状态改为ZOMBIE，若该进程父进程在等待子进程状态，则将父进程状态置为RUNNABLE并调度

2.请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）

```
alloc_proc								   PROC_ZOMBIE
	|											/\
   \/											|
PROC_UNINIT -- proc_init/wakeup_proc --> PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --> PROC_SLEEPING								           		/\                                                   | 												|                                                    |
												+--------------------wakeup_proc---------------------+



```